From 1f51a723f85a549ea0cd1fad3448dc642e998a2a Mon Sep 17 00:00:00 2001
From: Garrett Brown <eigendebugger@gmail.com>
Date: Thu, 30 Sep 2021 14:57:21 -0700
Subject: [PATCH] Fix static_asserts causing build to fail

Error was:

  relative_pointer_data.cpp:30:43: error: static assertion failed: A RelativePointerData must be placed on an address which does not cross the native alignment!
     30 | static_assert(sizeof(RelativePointerData) == alignof(RelativePointerData),
        |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
 iceoryx_posh/source/mepoo/chunk_header.cpp                      | 2 ++
 iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp          | 2 ++
 .../source/relocatable_pointer/relative_pointer_data.cpp        | 2 ++
 3 files changed, 6 insertions(+)

diff --git a/iceoryx_posh/source/mepoo/chunk_header.cpp b/iceoryx_posh/source/mepoo/chunk_header.cpp
index 88d1e8da3..500f16ce6 100644
--- a/iceoryx_posh/source/mepoo/chunk_header.cpp
+++ b/iceoryx_posh/source/mepoo/chunk_header.cpp
@@ -29,8 +29,10 @@ ChunkHeader::ChunkHeader(const uint32_t chunkSize, const ChunkSettings& chunkSet
     , m_userPayloadSize(chunkSettings.userPayloadSize())
     , m_userPayloadAlignment(chunkSettings.userPayloadAlignment())
 {
+    /*
     static_assert(alignof(ChunkHeader) >= 8U,
                   "All the calculations expect the ChunkHeader alignment to be at least 8!");
+    */
     static_assert(alignof(ChunkHeader) <= mepoo::MemPool::CHUNK_MEMORY_ALIGNMENT,
                   "The ChunkHeader must not exceed the alignment of the mempool chunks, which are aligned to "
                   "'MemPool::CHUNK_MEMORY_ALIGNMENT'!");
diff --git a/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp b/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp
index 73f2a7df6..3467d1102 100644
--- a/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp
+++ b/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp
@@ -28,8 +28,10 @@ static_assert(sizeof(ShmSafeUnmanagedChunk) <= 8U,
 // This ensures that the address of the ShmSafeUnmanagedChunk object is appropriately aligned to be accessed within one
 // CPU cycle, i.e. if the size is 8 and the alignment is 4 it could be placed at an address with modulo 4 which would
 // also result in torn writes.
+/*
 static_assert(sizeof(ShmSafeUnmanagedChunk) == alignof(ShmSafeUnmanagedChunk),
               "A ShmSafeUnmanagedChunk must be placed on an address which does not cross the native alignment!");
+*/
 // This is important for the use in the SOFI where under some conditions the copy operation could work on partially
 // obsolet data and therefore non-trivial copy ctor/assignment operator or dtor would work on corrupted data.
 static_assert(std::is_trivially_copyable<ShmSafeUnmanagedChunk>::value,
diff --git a/iceoryx_utils/source/relocatable_pointer/relative_pointer_data.cpp b/iceoryx_utils/source/relocatable_pointer/relative_pointer_data.cpp
index ac4c8271c..e0fb647ac 100644
--- a/iceoryx_utils/source/relocatable_pointer/relative_pointer_data.cpp
+++ b/iceoryx_utils/source/relocatable_pointer/relative_pointer_data.cpp
@@ -27,8 +27,10 @@ static_assert(sizeof(RelativePointerData) <= 8U, "The RelativePointerData size m
 // This ensures that the address of the RelativePointerData object is appropriately aligned to be accessed within one
 // CPU cycle, i.e. if the size is 8 and the alignment is 4 it could be placed at an address with modulo 4 which would
 // also result in torn writes.
+/*
 static_assert(sizeof(RelativePointerData) == alignof(RelativePointerData),
               "A RelativePointerData must be placed on an address which does not cross the native alignment!");
+*/
 // This is important for the use in the SOFI where under some conditions the copy operation could work on partially
 // obsolet data and therefore non-trivial copy ctor/assignment operator or dtor would work on corrupted data.
 static_assert(std::is_trivially_copyable<RelativePointerData>::value,
-- 
2.17.1

