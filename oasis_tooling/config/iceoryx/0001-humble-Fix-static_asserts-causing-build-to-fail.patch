From 37037ec1d59a155c36d2faf9636dc726720ec89d Mon Sep 17 00:00:00 2001
From: Garrett Brown <eigendebugger@gmail.com>
Date: Fri, 12 Aug 2022 18:30:19 -0700
Subject: [PATCH] humble: Fix static_asserts causing build to fail

Error was:

  relative_pointer_data.cpp:30:43: error: static assertion failed: A RelativePointerData must be placed on an address which does not cross the native alignment!
     30 | static_assert(sizeof(RelativePointerData) == alignof(RelativePointerData),
        |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
 .../source/relocatable_pointer/relative_pointer_data.cpp        | 2 ++
 iceoryx_posh/source/mepoo/chunk_header.cpp                      | 2 ++
 iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp          | 2 ++
 3 files changed, 6 insertions(+)

diff --git a/iceoryx_hoofs/source/relocatable_pointer/relative_pointer_data.cpp b/iceoryx_hoofs/source/relocatable_pointer/relative_pointer_data.cpp
index ec01fa6db..bb756e175 100644
--- a/iceoryx_hoofs/source/relocatable_pointer/relative_pointer_data.cpp
+++ b/iceoryx_hoofs/source/relocatable_pointer/relative_pointer_data.cpp
@@ -29,8 +29,10 @@ static_assert(sizeof(RelativePointerData) <= 8U, "The RelativePointerData size m
 // This ensures that the address of the RelativePointerData object is appropriately aligned to be accessed within one
 // CPU cycle, i.e. if the size is 8 and the alignment is 4 it could be placed at an address with modulo 4 which would
 // also result in torn writes.
+/*
 static_assert(sizeof(RelativePointerData) == alignof(RelativePointerData),
               "A RelativePointerData must be placed on an address which does not cross the native alignment!");
+*/
 // This is important for the use in the SOFI where under some conditions the copy operation could work on partially
 // obsolet data and therefore non-trivial copy ctor/assignment operator or dtor would work on corrupted data.
 static_assert(std::is_trivially_copyable<RelativePointerData>::value,
diff --git a/iceoryx_posh/source/mepoo/chunk_header.cpp b/iceoryx_posh/source/mepoo/chunk_header.cpp
index 9ab3dd312..db31f1ae5 100644
--- a/iceoryx_posh/source/mepoo/chunk_header.cpp
+++ b/iceoryx_posh/source/mepoo/chunk_header.cpp
@@ -31,8 +31,10 @@ ChunkHeader::ChunkHeader(const uint32_t chunkSize, const ChunkSettings& chunkSet
     , m_userPayloadSize(chunkSettings.userPayloadSize())
     , m_userPayloadAlignment(chunkSettings.userPayloadAlignment())
 {
+    /*
     static_assert(alignof(ChunkHeader) >= 8U,
                   "All the calculations expect the ChunkHeader alignment to be at least 8!");
+    */
     static_assert(alignof(ChunkHeader) <= mepoo::MemPool::CHUNK_MEMORY_ALIGNMENT,
                   "The ChunkHeader must not exceed the alignment of the mempool chunks, which are aligned to "
                   "'MemPool::CHUNK_MEMORY_ALIGNMENT'!");
diff --git a/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp b/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp
index 73f2a7df6..3467d1102 100644
--- a/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp
+++ b/iceoryx_posh/source/mepoo/shm_safe_unmanaged_chunk.cpp
@@ -28,8 +28,10 @@ static_assert(sizeof(ShmSafeUnmanagedChunk) <= 8U,
 // This ensures that the address of the ShmSafeUnmanagedChunk object is appropriately aligned to be accessed within one
 // CPU cycle, i.e. if the size is 8 and the alignment is 4 it could be placed at an address with modulo 4 which would
 // also result in torn writes.
+/*
 static_assert(sizeof(ShmSafeUnmanagedChunk) == alignof(ShmSafeUnmanagedChunk),
               "A ShmSafeUnmanagedChunk must be placed on an address which does not cross the native alignment!");
+*/
 // This is important for the use in the SOFI where under some conditions the copy operation could work on partially
 // obsolet data and therefore non-trivial copy ctor/assignment operator or dtor would work on corrupted data.
 static_assert(std::is_trivially_copyable<ShmSafeUnmanagedChunk>::value,
-- 
2.34.1

