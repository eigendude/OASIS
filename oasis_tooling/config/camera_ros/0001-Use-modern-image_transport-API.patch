From 0e5b66f53a147a87341fb385e74bd20ced6d4aa1 Mon Sep 17 00:00:00 2001
From: Garrett Brown <garrett.brown@aclima.earth>
Date: Sat, 15 Nov 2025 10:26:07 -0800
Subject: [PATCH] Use modern image_transport API

---
 CMakeLists.txt     |   2 +
 package.xml        |   1 +
 src/CameraNode.cpp | 166 +++++++--------------------------------------
 3 files changed, 28 insertions(+), 141 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index aea7317..40d0721 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -18,6 +18,7 @@ set(PACKAGE_DEPENDENCIES
   "sensor_msgs"
   "camera_info_manager"
   "cv_bridge"
+  "image_transport"
 )
 foreach(PKGDEP IN LISTS PACKAGE_DEPENDENCIES)
   find_package(${PKGDEP} REQUIRED)
@@ -79,6 +80,7 @@ target_link_libraries(camera_component PUBLIC
   ${sensor_msgs_TARGETS}
   camera_info_manager::camera_info_manager
   cv_bridge::cv_bridge
+  image_transport::image_transport
 )
 target_include_directories(camera_component PUBLIC ${libcamera_INCLUDE_DIRS})
 target_link_libraries(camera_component PUBLIC ${libcamera_LINK_LIBRARIES})
diff --git a/package.xml b/package.xml
index 36d63b4..8d038ec 100644
--- a/package.xml
+++ b/package.xml
@@ -15,6 +15,7 @@
   <depend>sensor_msgs</depend>
   <depend>camera_info_manager</depend>
   <depend>cv_bridge</depend>
+  <depend>image_transport</depend>
 
   <exec_depend>ros2launch</exec_depend>
   <exec_depend>ament_index_python</exec_depend>
diff --git a/src/CameraNode.cpp b/src/CameraNode.cpp
index 6a743ca..b3786aa 100644
--- a/src/CameraNode.cpp
+++ b/src/CameraNode.cpp
@@ -15,6 +15,7 @@
 #include <cv_bridge/cv_bridge.h>
 #endif
 #include <atomic>
+#include <image_transport/image_transport.hpp>
 #include <iostream>
 #include <libcamera/base/shared_fd.h>
 #include <libcamera/base/signal.h>
@@ -97,38 +98,18 @@ private:
 
   bool use_node_time;
 
-  rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr pub_image;
-  rclcpp::Publisher<sensor_msgs::msg::CompressedImage>::SharedPtr pub_image_compressed;
-  rclcpp::Publisher<sensor_msgs::msg::CameraInfo>::SharedPtr pub_ci;
+  image_transport::CameraPublisher pub_camera;
 
   camera_info_manager::CameraInfoManager cim;
 
   ParameterHandler parameter_handler;
   std::string frame_id;
 
-#ifdef RCLCPP_HAS_PARAM_EXT_CB
-  // use new "post_set" callback to apply parameters
-  PostSetParametersCallbackHandle::SharedPtr param_cb_change;
-#else
-  OnSetParametersCallbackHandle::SharedPtr param_cb_change;
-#endif
-
-  // compression quality parameter
-  std::atomic_uint8_t jpeg_quality;
-
   void
   requestComplete(libcamera::Request *const request);
 
   void
   process(libcamera::Request *const request);
-
-  void
-  postParameterChange(const std::vector<rclcpp::Parameter> &parameters);
-
-#ifndef RCLCPP_HAS_PARAM_EXT_CB
-  rcl_interfaces::msg::SetParametersResult
-  onParameterChange(const std::vector<rclcpp::Parameter> &parameters);
-#endif
 };
 
 RCLCPP_COMPONENTS_REGISTER_NODE(camera::CameraNode)
@@ -182,42 +163,6 @@ get_sensor_format(const std::string &format_str)
   throw std::runtime_error("Invalid sensor_mode. Expected [width]:[height] but got " + format_str);
 }
 
-// The following function "compressImageMsg" is adapted from "CvImage::toCompressedImageMsg"
-// (https://github.com/ros-perception/vision_opencv/blob/066793a23e5d06d76c78ca3d69824a501c3554fd/cv_bridge/src/cv_bridge.cpp#L512-L535)
-// and covered by the BSD-3-Clause licence.
-void
-compressImageMsg(const sensor_msgs::msg::Image &source,
-                 sensor_msgs::msg::CompressedImage &destination,
-                 const std::vector<int> &params = std::vector<int>())
-{
-  namespace enc = sensor_msgs::image_encodings;
-
-  std::shared_ptr<CameraNode> tracked_object;
-  cv_bridge::CvImageConstPtr cv_ptr = cv_bridge::toCvShare(source, tracked_object);
-
-  destination.header = source.header;
-  cv::Mat image;
-  if (cv_ptr->encoding == enc::BGR8 || cv_ptr->encoding == enc::BGRA8 ||
-      cv_ptr->encoding == enc::MONO8 || cv_ptr->encoding == enc::MONO16)
-  {
-    image = cv_ptr->image;
-  }
-  else {
-    cv_bridge::CvImagePtr tempThis = std::make_shared<cv_bridge::CvImage>(*cv_ptr);
-    cv_bridge::CvImagePtr temp;
-    if (enc::hasAlpha(cv_ptr->encoding)) {
-      temp = cv_bridge::cvtColor(tempThis, enc::BGRA8);
-    }
-    else {
-      temp = cv_bridge::cvtColor(tempThis, enc::BGR8);
-    }
-    image = temp->image;
-  }
-
-  destination.format = "jpg";
-  cv::imencode(".jpg", image, destination.data, params);
-}
-
 
 CameraNode::CameraNode(const rclcpp::NodeOptions &options)
     : Node("camera", options),
@@ -234,14 +179,7 @@ CameraNode::CameraNode(const rclcpp::NodeOptions &options)
 #else
       cim(this),
 #endif
-      parameter_handler(this),
-      param_cb_change(
-#ifdef RCLCPP_HAS_PARAM_EXT_CB
-        add_post_set_parameters_callback(std::bind(&CameraNode::postParameterChange, this, std::placeholders::_1))
-#else
-        add_on_set_parameters_callback(std::bind(&CameraNode::onParameterChange, this, std::placeholders::_1))
-#endif
-      )
+      parameter_handler(this)
 {
   // pixel format
   rcl_interfaces::msg::ParameterDescriptor param_descr_format;
@@ -301,34 +239,14 @@ CameraNode::CameraNode(const rclcpp::NodeOptions &options)
   const rclcpp::ParameterValue &camera_id =
     declare_parameter("camera", rclcpp::ParameterValue {}, param_descr_ro.set__dynamic_typing(true));
 
-  // we cannot control the compression rate of the libcamera MJPEG stream
-  // ignore "jpeg_quality" parameter for MJPEG streams
-  if (libcamera::PixelFormat::fromString(format) != libcamera::formats::MJPEG) {
-    rcl_interfaces::msg::ParameterDescriptor jpeg_quality_description;
-    jpeg_quality_description.name = "jpeg_quality";
-    jpeg_quality_description.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
-    jpeg_quality_description.description = "Image quality for JPEG format";
-    jpeg_quality_description.read_only = false;
-    rcl_interfaces::msg::IntegerRange jpeg_range;
-    jpeg_range.from_value = 1;
-    jpeg_range.to_value = 100;
-    jpeg_range.step = 1;
-    jpeg_quality_description.integer_range = {jpeg_range};
-    // default to 95
-    jpeg_quality = declare_parameter<uint8_t>("jpeg_quality", 95, jpeg_quality_description);
-  }
-
   // use_node_time parameter
   rcl_interfaces::msg::ParameterDescriptor param_descr_use_node_time;
   param_descr_use_node_time.description = "use node time instead of sensor timestamp for image messages";
   param_descr_use_node_time.read_only = true;
   use_node_time = declare_parameter<bool>("use_node_time", false, param_descr_use_node_time);
 
-  // publisher for raw and compressed image
-  pub_image = this->create_publisher<sensor_msgs::msg::Image>("~/image_raw", 1);
-  pub_image_compressed =
-    this->create_publisher<sensor_msgs::msg::CompressedImage>("~/image_raw/compressed", 1);
-  pub_ci = this->create_publisher<sensor_msgs::msg::CameraInfo>("~/camera_info", 1);
+  // publisher for images and camera info
+  pub_camera = image_transport::create_camera_publisher(this, "~/image_raw");
 
   // start camera manager and check for cameras
   camera_manager.start();
@@ -658,55 +576,44 @@ CameraNode::process(libcamera::Request *const request)
       // prepare image messages
       const libcamera::StreamConfiguration &cfg = stream->configuration();
 
-      auto msg_img = std::make_unique<sensor_msgs::msg::Image>();
-      auto msg_img_compressed = std::make_unique<sensor_msgs::msg::CompressedImage>();
+      sensor_msgs::msg::Image msg_img;
+      sensor_msgs::msg::CompressedImage msg_img_compressed;
 
       if (format_type(cfg.pixelFormat) == FormatType::RAW) {
         // raw uncompressed image
         assert(buffer_info[buffer].size == bytesused);
-        msg_img->header = hdr;
-        msg_img->width = cfg.size.width;
-        msg_img->height = cfg.size.height;
-        msg_img->step = cfg.stride;
-        msg_img->encoding = get_ros_encoding(cfg.pixelFormat);
-        msg_img->is_bigendian = (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__);
-        msg_img->data.resize(buffer_info[buffer].size);
-        memcpy(msg_img->data.data(), buffer_info[buffer].data, buffer_info[buffer].size);
-
-        // compress to jpeg
-        if (pub_image_compressed->get_subscription_count()) {
-          try {
-            compressImageMsg(*msg_img, *msg_img_compressed,
-                             {cv::IMWRITE_JPEG_QUALITY, jpeg_quality});
-          }
-          catch (const cv_bridge::Exception &e) {
-            RCLCPP_ERROR_STREAM(get_logger(), e.what());
-          }
-        }
+        msg_img.header = hdr;
+        msg_img.width = cfg.size.width;
+        msg_img.height = cfg.size.height;
+        msg_img.step = cfg.stride;
+        msg_img.encoding = get_ros_encoding(cfg.pixelFormat);
+        msg_img.is_bigendian = (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__);
+        msg_img.data.resize(buffer_info[buffer].size);
+        memcpy(msg_img.data.data(), buffer_info[buffer].data, buffer_info[buffer].size);
       }
       else if (format_type(cfg.pixelFormat) == FormatType::COMPRESSED) {
         // compressed image
         assert(bytesused < buffer_info[buffer].size);
-        msg_img_compressed->header = hdr;
-        msg_img_compressed->format = get_ros_encoding(cfg.pixelFormat);
-        msg_img_compressed->data.resize(bytesused);
-        memcpy(msg_img_compressed->data.data(), buffer_info[buffer].data, bytesused);
+        msg_img_compressed.header = hdr;
+        msg_img_compressed.format = get_ros_encoding(cfg.pixelFormat);
+        msg_img_compressed.data.resize(bytesused);
+        memcpy(msg_img_compressed.data.data(), buffer_info[buffer].data, bytesused);
 
         // decompress into raw rgb8 image
-        if (pub_image->get_subscription_count())
-          cv_bridge::toCvCopy(*msg_img_compressed, "rgb8")->toImageMsg(*msg_img);
+        if (pub_camera.getNumSubscribers() > 0)
+          cv_bridge::toCvCopy(msg_img_compressed, "rgb8")->toImageMsg(msg_img);
       }
       else {
         throw std::runtime_error("unsupported pixel format: " +
                                  stream->configuration().pixelFormat.toString());
       }
 
-      pub_image->publish(std::move(msg_img));
-      pub_image_compressed->publish(std::move(msg_img_compressed));
-
+      // Get camera info
       sensor_msgs::msg::CameraInfo ci = cim.getCameraInfo();
       ci.header = hdr;
-      pub_ci->publish(ci);
+
+      // Publish image and camera info
+      pub_camera.publish(msg_img, ci);
     }
     else if (request->status() == libcamera::Request::RequestCancelled) {
       RCLCPP_ERROR_STREAM(get_logger(), "request '" << request->toString() << "' cancelled");
@@ -727,27 +634,4 @@ CameraNode::process(libcamera::Request *const request)
   }
 }
 
-void
-CameraNode::postParameterChange(const std::vector<rclcpp::Parameter> &parameters)
-{
-  // check non-control parameters
-  for (const rclcpp::Parameter &parameter : parameters) {
-    if (parameter.get_name() == "jpeg_quality") {
-      jpeg_quality = parameter.get_parameter_value().get<uint8_t>();
-    }
-  }
-}
-
-#ifndef RCLCPP_HAS_PARAM_EXT_CB
-rcl_interfaces::msg::SetParametersResult
-CameraNode::onParameterChange(const std::vector<rclcpp::Parameter> &parameters)
-{
-  postParameterChange(parameters);
-
-  rcl_interfaces::msg::SetParametersResult result;
-  result.successful = true;
-  return result;
-}
-#endif
-
 } // namespace camera
-- 
2.43.0

